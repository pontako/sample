package com.example.packet;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

public class PacketConverter {

    /**
     * パケットデータID定義
     *
     */
    public enum DataId {
        ID_RACEINFO_LESSON,
        ID_RACEINFO_FREERUN,
        ID_RACEINFO_CLUB;
    }
    
    /**
     * パケットデータ型定義
     *
     */
    public enum DataType {
        TYPE_INTEGER,
        TYPE_STRING;
    }

    /**
     * パケットデータenum定義
     *
     */
    public enum PacketData {

        /**
         * データID
         */
        DATA_ID(DataType.TYPE_INTEGER),
        /**
         * レース種別
         */
        RACE_TYPE(DataType.TYPE_INTEGER),
        /**
         * 授業日時
         */
        LESSON_DATE(DataType.TYPE_INTEGER),
        /**
         * 授業クラス
         */
        LESSON_CLASS(DataType.TYPE_STRING),
        /**
         * タイトル
         */
        TITLE(DataType.TYPE_STRING);

        /**
         * データ型
         */
        private DataType dataType;
        
        private PacketData(DataType dataType) {
            this.dataType = dataType;
        }

        public DataType getDataType() {
            return dataType;
        }

        public static PacketData fromOrdinal(int ordinal) {
            PacketData[] packetDatas = values();
            for (PacketData packetData : packetDatas) {
                if (packetData.ordinal() == ordinal) {
                    return packetData;
                }
            }
            return null;
        }
        
        public byte[] createByteArray(Object obj) {
            byte[] byteArray = null;
            byte[] baseArray = null;

            DataType dataType = getDataType();
            if (dataType == DataType.TYPE_INTEGER) {
                baseArray = getBaseByteArray(INTEGER_BYTE_SIZE);
                ByteBuffer bb = ByteBuffer.allocate(baseArray.length + INTEGER_BYTE_SIZE);
                bb.put(baseArray);
                bb.putInt((Integer)(obj));
                byteArray = bb.array();
            } else if (dataType == DataType.TYPE_STRING) {
                String str = (String)obj;
                try {
                    byte[] dataArray = str.getBytes(STRING_ENCODING);
                    baseArray = getBaseByteArray(dataArray.length);
                    ByteBuffer bb = ByteBuffer.allocate(baseArray.length + dataArray.length);
                    bb.put(baseArray);
                    bb.put(dataArray);
                    byteArray = bb.array();
                } catch (UnsupportedEncodingException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }

            return byteArray;
        }

        /**
         * ベース部(パケットデータIDとパケットデータ長)のbyte配列を返す
         * 
         * @param dataSize パケットデータサイズ(ベース部以外のデータサイズ)
         * @return ベース部のbyte配列
         */
        private byte[] getBaseByteArray(int dataSize) {
            ByteBuffer bb = ByteBuffer.allocate(
                    PACKET_DATA_ID_BYTE_SIZE + PACKET_DATA_LENGTH_BYTE_SIZE);
            bb.putInt(ordinal());
            bb.putInt(dataSize);
            return bb.array();
        }
    }

    /**
     * String型データのエンコーディング
     */
    private static final String STRING_ENCODING = "UTF-8";

    /**
     * int型のbyteサイズ
     */
    private static final int INTEGER_BYTE_SIZE = Integer.SIZE / Byte.SIZE;

    /**
     * パケットデータIDのbyteサイズ
     */
    private static final int PACKET_DATA_ID_BYTE_SIZE = INTEGER_BYTE_SIZE;
    
    /**
     * パケットデータ長のbyteサイズ
     */
    private static final int PACKET_DATA_LENGTH_BYTE_SIZE = INTEGER_BYTE_SIZE;

    
    /* ------------------------------------------------------ */
    // privateフィールド定義
    /* ------------------------------------------------------ */
    private DataId mDataId;

    /**
     * パケットデータ格納用マップ
     */
    private LinkedHashMap<PacketData, List<Object>> mPacketDataMap = 
        new LinkedHashMap<PacketData, List<Object>>();

    /* ------------------------------------------------------ */
    // コンストラクタ定義
    /* ------------------------------------------------------ */
    /**
     * コンストラクタ(byte配列に変換する際に使用する)
     * 
     * @param dataId データID
     */
    public PacketConverter(DataId dataId) {
        mDataId = dataId;
        putInt(PacketData.DATA_ID, dataId.ordinal());
    }

    /**
     * コンストラクタ(byte配列から復元時に使用する)
     * 
     * @param bytes byte配列
     */
    public PacketConverter(byte[] bytes) {
        if (bytes == null) {
            throw new RuntimeException("bytes == null");
        }
        putPacketData(bytes);
    }

    /* ------------------------------------------------------ */
    // publicメソッド定義
    /* ------------------------------------------------------ */
    /**
     * int型のパケットデータを追加する
     * 
     * @param packetType パケットデータ種別
     * @param value 値
     */
    public void putInt(PacketData packetType, int value) {
        put(packetType, DataType.TYPE_INTEGER, new Integer(value));
    }

    /**
     * String型のパケットデータを追加する
     * 
     * @param packetType パケットデータ種別
     * @param value 値
     */
    public void putString(PacketData packetType, String value) {
        put(packetType, DataType.TYPE_STRING, value);
    }

    /**
     * int型のパケットデータを取得する
     * 
     * <pre>
     * 同一パケットデータ種別で複数のデータが存在する場合は、
     * 先頭のデータを返す
     * </pre>
     * 
     * @param packetType パケットデータ種別
     * @return int型のパケットデータ
     */
    public int getInt(PacketData packetType) {
        Object obj = get(packetType, DataType.TYPE_INTEGER);
        return (Integer)(obj);
    }

    /**
     * String型のパケットデータを取得する
     * 
     * <pre>
     * 同一パケットデータ種別で複数のデータが存在する場合は、
     * 先頭のデータを返す
     * </pre>
     * 
     * @param packetType パケットデータ種別
     * @return String型のパケットデータ
     */
    public String getString(PacketData packetType) {
        Object obj = get(packetType, DataType.TYPE_STRING);
        return (String)(obj);
    }

    /**
     * int型のパケットデータリストを取得する
     * 
     * <pre>
     * 同一パケットデータ種別で複数のデータが存在する場合に、
     * 使用する
     * </pre>
     * 
     * @param packetType パケットデータ種別
     * @return int型のパケットデータリスト
     */
    public int[] getIntArray(PacketData packetType) {
        if (packetType.getDataType() != DataType.TYPE_INTEGER) {
            throw new RuntimeException("invalid data type");
        }
        
        List<Object> list = mPacketDataMap.get(packetType);
        if ((list == null) || (list.size() <= 0)) {
            throw new RuntimeException("failed to get packetData");
        }
        
        int[] intArray = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            int value = (Integer)list.get(i);
            intArray[i] = value;
        }
        
        return intArray;
    }

    /**
     * String型のパケットデータリストを取得する
     * 
     * <pre>
     * 同一パケットデータ種別で複数のデータが存在する場合に、
     * 使用する
     * </pre>
     * 
     * @param packetType パケットデータ種別
     * @return String型のパケットデータリスト
     */
    public String[] getStringArray(PacketData packetType) {
        if (packetType.getDataType() != DataType.TYPE_STRING) {
            throw new RuntimeException("invalid data type");
        }
        
        List<Object> list = mPacketDataMap.get(packetType);
        if ((list == null) || (list.size() <= 0)) {
            throw new RuntimeException("failed to get packetData");
        }
        
        String[] stringArray = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            String value = (String)list.get(i);
            stringArray[i] = value;
        }
        
        return stringArray;
    }

    /**
     * データIDを返す
     * 
     * @return データID
     */
    public DataId getDataId() {
        return mDataId;
    }

    /**
     * byte配列を取得する
     * 
     * @return byte配列
     */
    public byte[] getByteArray() {
        byte[] byteArray = null;
        List<byte[]> bytes = new ArrayList<byte[]>();
        int byteArrayLength = 0;

        Iterator<Entry<PacketData, List<Object>>> it = 
            mPacketDataMap.entrySet().iterator();
        while (it.hasNext()) {
            Entry<PacketData, List<Object>> entry = it.next();
            PacketData packetType = entry.getKey();
            List<Object> list = entry.getValue();
            for (Object obj : list) {
                byte[] oneData = packetType.createByteArray(obj);
                bytes.add(oneData);
                byteArrayLength += oneData.length;
                System.out.println("--->packetType:" + packetType);
                for (byte b : oneData) {
                    System.out.println("byte:" + String.format("%02X", b));
                }
            }
            
        }

        if (bytes != null) {
            ByteBuffer bb = ByteBuffer.allocate(byteArrayLength);
            for (byte[] b : bytes) {
                bb.put(b);
            }
            byteArray = bb.array();
        }

        
        return byteArray;
    }

    /* ------------------------------------------------------ */
    // privateメソッド定義
    /* ------------------------------------------------------ */
    /**
     * パケットデータを追加する
     * 
     * @param packetType パケットデータ種別
     * @param dataType パケットデータ型
     * @param value 値
     */
    private void put(PacketData packetType, DataType dataType, Object value) {
        if (packetType.getDataType() != dataType) {
            throw new RuntimeException("invalid data type");
        }
        if (value == null) {
            throw new RuntimeException("invalid value");
        }
        List<Object> list = mPacketDataMap.get(packetType);
        if (list == null) {
            list = new ArrayList<Object>();
        }
        list.add(value);
        mPacketDataMap.put(packetType, list);
    }

    /**
     * パケットデータを取得する
     * 
     * @param packetType パケットデータ種別
     * @param dataType パケットデータ型
     * @return パケットデータ
     */
    private Object get(PacketData packetType, DataType dataType) {
        if (packetType.getDataType() != dataType) {
            throw new RuntimeException("invalid data type");
        }

        List<Object> list = mPacketDataMap.get(packetType);
        if ((list == null) || (list.size() <= 0)) {
            throw new RuntimeException("failed to get packetData");
        }

        return list.get(0);
    }

    /**
     * byte配列からパケットデータを生成する
     * 
     * @param bytes byte配列
     */
    private void putPacketData(byte[] bytes) {
//        パケットデータフォーマット
//        4byte, 4byte,   *byte(可変)
//       [id,    length,  data]

        System.out.println("---------------->start parse");
        int currentIndex = 0;
        while (currentIndex < bytes.length) {
            // データ種別を取得.
            int dataIdStartIndex = currentIndex;
            PacketData packetType = getPacketData(bytes, dataIdStartIndex);

            // データ長を取得.
            int dataLengthStartIndex = dataIdStartIndex + PACKET_DATA_ID_BYTE_SIZE;
            int dataLength = getPacketDataLength(bytes, dataLengthStartIndex);

            // データを追加.
            int dataStartIndex = dataLengthStartIndex + PACKET_DATA_LENGTH_BYTE_SIZE;
            putPacketData(bytes, dataStartIndex, dataLength, packetType);

            // インデックスを加算.
            currentIndex += PACKET_DATA_ID_BYTE_SIZE
                    + PACKET_DATA_LENGTH_BYTE_SIZE + dataLength;
        }
    }

    /**
     * パケットデータを取得する
     * 
     * @param bytes byte配列
     * @param start 開始インデックス
     * @return パケットデータ
     */
    private PacketData getPacketData(byte[] bytes, int start) {
        int end = start + PACKET_DATA_ID_BYTE_SIZE;
        byte[] dataIdBytes = Arrays.copyOfRange(bytes, start, end);
        ByteBuffer buf = ByteBuffer.wrap(dataIdBytes);
        int dataId = buf.getInt();
        return PacketData.fromOrdinal(dataId);
    }

    /**
     * パケットデータ長を取得する
     * 
     * @param bytes byte配列
     * @param start 開始インデックス
     * @return パケットデータ長
     */
    private int getPacketDataLength(byte[] bytes, int start) {
        int end = start + PACKET_DATA_ID_BYTE_SIZE;
        byte[] dataLengthBytes = Arrays.copyOfRange(bytes, start, end);
        ByteBuffer buf = ByteBuffer.wrap(dataLengthBytes);
        int dataLength = buf.getInt();
        return dataLength;
    }

    /**
     * パケットデータを追加する
     * 
     * @param bytes byte配列
     * @param start 開始インデックス
     * @param dataLength データ長
     * @param packetType パケットデータ
     */
    private void putPacketData(byte[] bytes, int start, int dataLength,
            PacketData packetType) {
        int end = start + dataLength;
        byte[] dataBytes = Arrays.copyOfRange(bytes, start, end);
        
        DataType dataType = packetType.getDataType();
        if (dataType == DataType.TYPE_INTEGER) {
            ByteBuffer buf = ByteBuffer.wrap(dataBytes);
            int data = buf.getInt();
            putInt(packetType, data);
            System.out.println("packetType:" + packetType + " value:" + data);
        } else if (dataType == DataType.TYPE_STRING) {
            String str = null;
            try {
                str = new String(dataBytes, STRING_ENCODING);
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
            putString(packetType, str);
            System.out.println("packetType:" + packetType + " value:" + str);
        }
    }
}
